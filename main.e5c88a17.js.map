{"version":3,"sources":["scripts/main.js"],"names":[],"mappings":";AAAA","file":"main.e5c88a17.js","sourceRoot":"..\\src","sourcesContent":["'use strict';\r\n\r\n// class Game {\r\n//   static fieldOfGame = [\r\n//   [0, 0, 0, 0],\r\n//   [0, 0, 0, 0],\r\n//   [0, 0, 0, 0],\r\n//   [0, 0, 0, 0],\r\n// ];\r\n\r\n// // if a field is not square we should use two variables for its sizes\r\n//   static fieldSize = Game.fieldOfGame.length;\r\n//   static movable = false;\r\n//   static countMovedCells = 0;\r\n//   static numberOfMergeableCells = 0;\r\n//   static currentScore = 0;\r\n\r\n//   static startMessage = document.querySelector('.message-start');\r\n//   static winMessage = document.querySelector('.message-win');\r\n//   static loseMessage = document.querySelector('.message-lose');\r\n//   static fieldRows = document.querySelector('.game-field').rows;\r\n//   static scoreboard = document.querySelector('.game-score');\r\n\r\n//   static findEmptyCells() {\r\n//       const cellsArray = [];\r\n\r\n//       for (let i = 0; i < Game.fieldSize; i++) {\r\n//         for (let j = 0; j < Game.fieldSize; j++) {\r\n//           if (Game.fieldOfGame[i][j] === 0) {\r\n//             cellsArray.push(`${i}${j}`);\r\n//           }\r\n//         }\r\n//       }\r\n\r\n//       if (cellsArray.length === 0) {\r\n//         Game.movable = false;\r\n//       } else {\r\n//         Game.movable = true;\r\n//       }\r\n\r\n//       return cellsArray;\r\n//     }\r\n\r\n//   static defineCreatingCellValue() {\r\n//     const isFour = parseInt(Math.random() * 10) + 1;\r\n//     if (isFour === 4) {\r\n//       return 4;\r\n//     } else {\r\n//       return 2;\r\n//     }\r\n//   }\r\n\r\n//   static findCoordsForNewCell() {\r\n//     const emptyCellsArray = Game.findEmptyCells();\r\n\r\n//     const cellForCreationNumber\r\n//       = parseInt(Math.random() * emptyCellsArray.length);\r\n\r\n//     return emptyCellsArray[cellForCreationNumber].split('');\r\n//   }\r\n\r\n//   static createCell() {\r\n//     const cellCoords = Game.findCoordsForNewCell();\r\n\r\n//     Game.fieldOfGame[+cellCoords[0]][+cellCoords[1]]\r\n//       = Game.defineCreatingCellValue();\r\n//   }\r\n\r\n//   static startGame() {\r\n//     Game.countMovedCells = 0;\r\n//     Game.currentScore = 0;\r\n\r\n//     Game.clearCells();\r\n//     Game.createCell();\r\n//     Game.createCell();\r\n\r\n//     Game.render('start', 'start');\r\n\r\n//     document.addEventListener('keydown', Game.handleArrowPress);\r\n//   }\r\n\r\n//   static clearCells() {\r\n//     for (let i = 0; i < Game.fieldSize; i++) {\r\n//       for (let j = 0; j < Game.fieldSize; j++) {\r\n//         Game.fieldOfGame[i][j] = 0;\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   static changeCellClass(cell, cellNewValue) {\r\n//     if (cell.classList.contains(`field-cell--${cell.innerText}`)) {\r\n//       cell.classList.remove(`field-cell--${cell.innerText}`);\r\n//     }\r\n\r\n//     if (cellNewValue !== 0) {\r\n//       cell.classList.add(`field-cell--${cellNewValue}`);\r\n//     }\r\n//   }\r\n\r\n//   static renderfieldOfGame() {\r\n//     for (let i = 0; i < Game.fieldSize; i++) {\r\n//       for (let j = 0; j < Game.fieldSize; j++) {\r\n//         if (Game.fieldOfGame[i][j] !== 0) {\r\n//           Game.changeCellClass(Game.fieldRows[i].cells[j],\r\n//              Game.fieldOfGame[i][j]);\r\n//           Game.fieldRows[i].cells[j].innerText = Game.fieldOfGame[i][j];\r\n//         } else {\r\n//           Game.changeCellClass(Game.fieldRows[i].cells[j],\r\n//            Game.fieldOfGame[i][j]);\r\n//           Game.fieldRows[i].cells[j].innerText = '';\r\n//         }\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   static renderMesage(currentMesage) {\r\n//     switch (currentMesage) {\r\n//       case 'win':\r\n//         Game.winMessage.classList.remove('hidden');\r\n//         break;\r\n\r\n//       case 'lose':\r\n//         Game.loseMessage.classList.remove('hidden');\r\n//         break;\r\n\r\n//       case 'prepareForStart':\r\n//         Game.winMessage.classList.add('hidden');\r\n//         Game.loseMessage.classList.add('hidden');\r\n//         Game.startMessage.classList.remove('hidden');\r\n//         break;\r\n\r\n//       case 'start':\r\n//         Game.startMessage.classList.add('hidden');\r\n//         Game.winMessage.classList.add('hidden');\r\n//         Game.loseMessage.classList.add('hidden');\r\n//     }\r\n//   }\r\n\r\n//   static renderButton(buttonType) {\r\n//     const startButton = document.querySelector('.start');\r\n\r\n//     switch (buttonType) {\r\n//       case 'prepareForStart':\r\n//         startButton.addEventListener('click', () => Game.startGame());\r\n\r\n//         startButton.classList.add('start');\r\n//         startButton.innerText = 'Start';\r\n\r\n//         break;\r\n\r\n//       case 'start':\r\n//         if (startButton) {\r\n//           startButton.classList.remove('start');\r\n//           startButton.classList.add('restart');\r\n//           startButton.innerText = 'Restart';\r\n//         }\r\n\r\n//         break;\r\n//     }\r\n//   }\r\n\r\n//   static render(message, button) {\r\n//     Game.renderfieldOfGame();\r\n//     Game.scoreboard.innerText = Game.currentScore;\r\n//     Game.renderMesage(message);\r\n//     Game.renderButton(button);\r\n//   }\r\n\r\n//   static createMatrixClone() {\r\n//     const matrixClone = [\r\n//       [0, 0, 0, 0],\r\n//       [0, 0, 0, 0],\r\n//       [0, 0, 0, 0],\r\n//       [0, 0, 0, 0],\r\n//     ];\r\n\r\n//     for (let i = 0; i < Game.fieldSize; i++) {\r\n//       for (let j = 0; j < Game.fieldSize; j++) {\r\n//         matrixClone[i][j] = Game.fieldOfGame[i][j];\r\n//       }\r\n//     }\r\n\r\n//     return matrixClone;\r\n//   }\r\n\r\n//   static getTargetValue(fieldTemp, rotationDirection, row, column) {\r\n//     let targetValue;\r\n\r\n//     switch (rotationDirection) {\r\n//       case 'left':\r\n//         targetValue = fieldTemp[column][Game.fieldSize - row - 1];\r\n//         break;\r\n\r\n//       case 'right':\r\n//         targetValue = fieldTemp[Game.fieldSize - column - 1][row];\r\n//         break;\r\n\r\n//       case 'down':\r\n//         targetValue = fieldTemp[Game.fieldSize - row - 1][column];\r\n//         break;\r\n//     }\r\n\r\n//     return targetValue;\r\n//   }\r\n\r\n//   static rotateMatrix(direction) {\r\n//     const tempField = Game.createMatrixClone(Game.fieldOfGame);\r\n\r\n//     for (let i = 0; i < Game.fieldSize; i++) {\r\n//       for (let j = 0; j < Game.fieldSize; j++) {\r\n//         Game.fieldOfGame[i][j]\r\n//            = Game.getTargetValue(tempField, direction, i, j);\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   static moveCells() {\r\n//     for (let i = Game.fieldSize - 1; i > 0; i--) {\r\n//       for (let j = 0; j < Game.fieldSize; j++) {\r\n//         if (Game.fieldOfGame[i - 1][j] === 0\r\n//             && Game.fieldOfGame[i][j] !== 0) {\r\n//           Game.fieldOfGame[i - 1][j] = Game.fieldOfGame[i][j];\r\n//           Game.fieldOfGame[i][j] = 0;\r\n//           Game.countMovedCells++;\r\n//         }\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   static mergeCells() {\r\n//     for (let i = 0; i < Game.fieldSize - 1; i++) {\r\n//       for (let j = 0; j < Game.fieldSize; j++) {\r\n//         if (Game.fieldOfGame[i][j] === Game.fieldOfGame[i + 1][j]\r\n//             && Game.fieldOfGame[i][j] !== 0) {\r\n//           Game.fieldOfGame[i][j] = Game.fieldOfGame[i + 1][j] * 2;\r\n//           Game.fieldOfGame[i + 1][j] = 0;\r\n//           Game.currentScore += Game.fieldOfGame[i][j];\r\n//           Game.countMovedCells++;\r\n//         }\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   static makeChanges() {\r\n//     for (let i = 0; i < Game.fieldSize - 1; i++) {\r\n//       Game.moveCells();\r\n//     }\r\n\r\n//     Game.mergeCells();\r\n\r\n//     for (let i = 0; i < Game.fieldSize - 1; i++) {\r\n//       Game.moveCells();\r\n//     }\r\n//   }\r\n\r\n//   static findCellsForMerge() {\r\n//     for (let i = 0; i < Game.fieldSize - 1; i++) {\r\n//       for (let j = 0; j < Game.fieldSize; j++) {\r\n//         if (Game.fieldOfGame !== 0) {\r\n//           if (Game.fieldOfGame[i][j] === Game.fieldOfGame[i + 1][j]) {\r\n//             Game.numberOfMergeableCells++;\r\n\r\n//             return;\r\n//           }\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     for (let i = 0; i < Game.fieldSize; i++) {\r\n//       for (let j = 0; j < Game.fieldSize - 1; j++) {\r\n//         if (Game.fieldOfGame !== 0) {\r\n//           if (Game.fieldOfGame[i][j] === Game.fieldOfGame[i][j + 1]) {\r\n//             Game.numberOfMergeableCells++;\r\n\r\n//             return;\r\n//           }\r\n//         }\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   static checkWinScenario() {\r\n//     for (let i = 0; i < Game.fieldSize; i++) {\r\n//       for (let j = 0; j < Game.fieldSize; j++) {\r\n//         if (Game.fieldOfGame[i][j] === 2048) {\r\n//           return true;\r\n//         }\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   static checkLoseScenario() {\r\n//     if (!Game.movable && Game.numberOfMergeableCells === 0) {\r\n//       return true;\r\n//     }\r\n//   }\r\n\r\n//   static prepareForNewRound() {\r\n//     document.addEventListener('keydown', Game.handleArrowPress);\r\n//     Game.countMovedCells = 0;\r\n//     Game.movable = false;\r\n//     Game.numberOfMergeableCells = 0;\r\n\r\n//     Game.render('start', 'start');\r\n//   }\r\n\r\n//   static finishRound() {\r\n//     if (Game.countMovedCells === 0) {\r\n//       return;\r\n//     }\r\n\r\n//     document.removeEventListener('keydown', Game.handleArrowPress);\r\n\r\n//     if (Game.checkWinScenario()) {\r\n//       Game.render('start', 'start');\r\n\r\n//       setTimeout(() => {\r\n//         Game.finishGame('win');\r\n//       }, 1000);\r\n\r\n//       return;\r\n//     }\r\n\r\n//     setTimeout(Game.createCell, 200);\r\n\r\n//     setTimeout(() => {\r\n//       Game.findEmptyCells();\r\n//       Game.findCellsForMerge();\r\n\r\n//       if (Game.checkLoseScenario()) {\r\n//         Game.render('start', 'start');\r\n//         Game.finishGame('lose');\r\n\r\n//         return;\r\n//       }\r\n\r\n//       Game.prepareForNewRound();\r\n//     }, 300);\r\n//   }\r\n\r\n//   static finishGame(gameResult) {\r\n//     document.removeEventListener('keydown', Game.handleArrowPress);\r\n\r\n//     Game.clearCells();\r\n\r\n//     Game.currentScore = 0;\r\n\r\n//     if (gameResult === 'win') {\r\n//       Game.render('win', 'start');\r\n//     } else {\r\n//       Game.loseMessage.classList.remove('hidden');\r\n//     }\r\n//   }\r\n\r\n//   static handleArrowPress(e) {\r\n//     e.preventDefault();\r\n\r\n//     switch (e.code) {\r\n//       case 'ArrowUp':\r\n//         Game.makeChanges();\r\n//         Game.finishRound();\r\n//         break;\r\n\r\n//       case 'ArrowDown':\r\n//         Game.rotateMatrix('down');\r\n//         Game.makeChanges();\r\n//         Game.rotateMatrix('down');\r\n//         Game.finishRound();\r\n//         break;\r\n\r\n//       case 'ArrowLeft':\r\n//         Game.rotateMatrix('right');\r\n//         Game.makeChanges();\r\n//         Game.rotateMatrix('left');\r\n//         Game.finishRound();\r\n//         break;\r\n\r\n//       case 'ArrowRight':\r\n//         Game.rotateMatrix('left');\r\n//         Game.makeChanges();\r\n//         Game.rotateMatrix('right');\r\n//         Game.finishRound();\r\n//         break;\r\n//     }\r\n//   }\r\n// }\r\n\r\n// Game.render('prepareForStart', 'prepareForStart');\r\n"]}